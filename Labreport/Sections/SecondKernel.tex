% -- Extracting satd_4x4 ---------------------------------------

\section{Extracting a Second Kernel}
\label{sec:second}
For lab 3, a second kernel has to be extracted in order to achieve an even higher speed up. For this assignment, we wanted to choose our kernel more wisely. Given the constant competition for the use of the FPGAs, \mcode{bytecode} has to be written to the instruction memory everytime the kernel is being called. In combination with the data to be processed by the kernel, this leads to huge data traffic which is actually slowing down the application. This is why we wanted, at first, to pick a kernel that is not being called too often but requires a lot of heavy computation. A candidate for this would be the \mcode{halfpel} kernel, which has quite its share in execution time but not that many functions calls. The half- and quarter are the functions that ensure the motion estimation in x264 and can consume up to 90\% of the total computing time in HD videos. As these functions are not called that often, they consume relatively less time in communication between the MicroBlaze and the $\rho$-VEX and are therefor far more valuable to optimize using parallel computing. However, considering the time constraints and the set backs in this projects we choose a kernel similar to \mcode{pixel_satd_8x4} which also has a large share in the execution time: \mcode{pixel_satd_4x4}.

\subsection{Extract \mcode{pixel_satd_4x4}}
\label{sec:4x4}
There is not a lot of difference in \mcode{pixel_satd_8x4} and \mcode{pixel_satd_4x4}. The main difference concerns the stride when writing the pixel streams to the data memory. Other than \mcode{pixel\_satd\_8x4}, the stride is four instead of eight bytes. Because this kernel is relatively easy to implement in the $\rho$-VEX as well, we decided to invest some time into comparing the effect of using a merged \mcode{bytecode} or two separate \mcode{bytecodes}. The first approach is to use a single \mcode{bytecode}, which extends the \mcode{pixel\_satd\_8x4 bytecode} with a second kernel that implemented \mcode{pixel_satd_4x4}. The \mcode{pixel.c} informs the $\rho$-VEX about which function it has to run. This is being solved by reserving a byte in the datamemory at location \mcode{0x40} where we either wrote \mcode{0x84} or \mcode{0x44}. The $\rho$-VEX is then able to read from this data location and determine which function it would have to run. 

A big downside on this solution however is that the total \mcode{bytecode} of these combined kernels is 3744 bytes. Loading such a large amount into the instruction memory everytime the function is called can slow down the application a lot. Therefor we decide to divide the two kernels into two separate bytecodes of less than 2000 bytes. Now, \mcode{pixel.c} only has to load a different \mcode{bytecode} into the instruction memory when the different kernels are called. Both bytecodes have to be loaded into a codebuffer. This is done in the \mcode{x264.c} file and the codebuffers are declared in the common file \mcode{common.h}