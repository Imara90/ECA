% Self-aware adaptation in FPGA-based systems

Self-aware adaptive computing systems are capable or adapting their behavior and resources thousands of times based on changing environmental conditions and demands. This allows them to automatically accomplish their goals in the best way possible. The results of the papers presents a system built on top of a set of enabling technology that proves the effectiveness of using self-aware adaptive computing systems.

Because of the increasing system complexities, it is unfeasible for the average programmer to weight all the constraints and optimize systems for a wide range of machines. Self-aware adaptive computing focuses on creating a balance of resources to improve performance, utilization, reliability and programmability. A programmer will ideally only have to provide the system its goal, rather than a description of tasks, provided with some constraints.

A self-aware adaptive computing system becomes an active system where the hardware, application and the operating system has to be seen as unique entities to autonomously adapt itself. The underlying architecture has cognitive hardware mechanisms In its core to observe and affect the execution. The self-aware adaptive computing system also implements learning and decision making engines  to determine appropriate actions. A key challenge is to identify what parts of a computer need to be adapted and to quantify the degree of which adaption can afford savings in metrics of interest of us.

The operating systems chooses at run-time among a set of possible implementations according to the criteria. This decision is based on the Observe-decide-act. The need for this dynamic choice between available implementations is give by the fact that the system is live and lives in an unpredictable environment.

When the throughput of the heart monitor over a certain window of time drops under a certain limit, the heuristics for hot-swapping are activated. A thing to keep in mind is that the heartbeats application contains an overhead of 3,52% which is moderate. It would be better if the application could be lightweight.

The results of a first static analysis showed that hardware implementations are generally faster than software applications. However, when considering dynamic scenario's, execution times might change radically.
