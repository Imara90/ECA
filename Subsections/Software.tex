% Software based approaches
%
\cite{selfaware} presents an implementation of a FPGA-based self-aware adaptive computing system which blends several software based techniques such as \emph{monitoring, decision making} and \emph{self-adaptation}. This system is built on top of a heterogeneous architecture enabling and utilizing the effectiveness of these adaptive computing systems. The operating system on top enables performance monitoring and can take actions involving software and hardware adaptation as seen in the \emph{observe-decide-act (ODA) loop}. Given certain performance goals these loops \emph{observe} the current state, \emph{decide} upon an action and \emph{acts} accordingly as will be discussed in Section \ref{sec:selfawareness}, \ref{sec:decisions} and \ref{sec:selfadapting}. \cite{selfaware} presents the \emph{application Heartbeats} to asses and monitor performance and progress and the \emph{Implementation Switch Service} to switch between different implementations of the same functionality using a heuristic based decision mechanism. 

The Heartbeats application is a monitoring application which makes it possible to assert performance goals as heart-rate windows delimited by a minimum and maximum performance, or \emph{heart-rate} \cite{evolvable}. The Heartbeats API is made of small straightforward functions and allows declaring performance goals. Software components first have to register, specifying parameters such as minimum and maxmim heart-reate, size of the windows of observation and history buffers \cite{selfaware}. The application then updates the progress of the execution calling the function that signifies a heartbeat \cite{evolvable}.

The implementation switch service presented in \cite{selfaware} inspired by the \emph{hot-swap mechanism} is fundamental for the system to switch between different implementations of the same functionality at run-time. Since threads can access data structures concurrently and data structures can differ for different implementations, they propose a framework to account for these shortcomings in the hot-swap mechanism.  This framework is divided in three sub-phases: a prior phase representing the common work scenario, a transfer phase that blocks new requests in order to reach a quiescent state, translated to fit another data structure and a post phase in which the blocked and new requests are allowed to proceed. 
